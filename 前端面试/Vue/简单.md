**1、MVC 和 MVVM 的区别**

MVC：Controller 把 Model 的数据赋值给 View。Model 模型，处理数据逻辑的部分；View 视图，处理数据显示的部分； Controller 控制器，处理用户交互的部分；

MVVM：新增了 VM 类

- ViewModel 层：做了两件事达到了数据的双向绑定
  1. 将模型转换成了视图，实现方式是数据绑定
  2. 将视图转换成模型，实现方式是事件监听
- 与 MVC 的区别是：MVVM 实现了 View 和 Model 的自动同步，也就说，当 Model 的属性变化时，不用再自己手动操作 Dom 元素来改变 View 的显示，而是改变属性后，该属性对应的 View 层会自动改变（对应的是 Vue 数据驱动的思想）
- MVVM 比 MVC 精简了很多，不仅简化了业务和界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。
- Vue 并没有完全遵循 MVVM 的思想：
  - 因为严格的 MVVM  要求 View 和 Model 不能直接通信，而 Vue 提供了 $refs 这个属性，让 Model 可以直接操作 View，违反了这一规定。



**2、为什么 data 是一个函数**

组件中的 data 写成一个函数，数据以函数返回值的形式定义，这样，每复用一个组件，就会返回一份新的 data，类似于给每个组件实例创建了了一个私密的数据空间，让各个组件维护各自的数据；如果写成对象的形式，就使得所有组件实例都公用一份 data，就会造成一个变了全都会变的结果。



**3、Vue 组件通讯有哪几种方式**

1. props 和 $emit：父组件通过 props 传递数据给子组件，子组件通过 $emit 触发事件传递数据给父组件；
2. $parent 和 $children：获取当前组件的父组件和子组件；
3. $attrs 和 $listeners：$attrs与$listeners 是两个对象，$attrs 里存放的是父组件中绑定的**非 Props 属性**，$listeners里存放的是父组件中绑定的**非原生事件**。
4. $refs：获取组件实例
5. eventBus：兄弟组件数据传递，这种情况下可以使用事件总线的方式
6. vuex 状态管理
7. 父组件通过 provide 提供变量，然后在子组件中通过 inject 注入变量。（官方不推荐在实际业务中使用，但是写组件库很常用）



**Vue 的生命周期方法有哪些，一般在哪一步发请求**

**beforeCreate：**在实例初始化之后，数据观测（data observer）和 event/watcher 事件配置之前被调用。在当前阶段，data、methods、computed 以及 watch 上的数据和方法都不能被访问。

**created：**实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测（data observer）、属性和方法的运算、event/watch 事件回调。这里没有 $el（获取 Vue 实例关联的 DOM 元素），如果非要与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom。

**beforeMount：**在挂载之前被调用：相关的 render 函数首次被调用。

**mounted：**在挂载完成之后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点。

**beforeUpdate：**数据更新时调用，发生在虚拟 Dom 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这个不会触发附加的重渲染过程。

**updated：**发生在更新完成之后，当前阶段组件、Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能导致无限循环的更新，该钩子在服务端渲染期间不被调用。

**beforeDestroy：**实例销毁之前被调用。在这一步，实例仍然完全可用。可以在这时进行善后收尾工作，比如清除计时器。

**destroyed：**实例销毁后调用。调用后，Vue 实例指示的所有东西都会解除绑定，所有的事件监听器都会被移除，所有的子实例也会被销毁。该钩子在服务器渲染期间不被调用。

**activated：**keep-alive 专属，组件被激活时调用。

**deactivated：**keep-alive 专属，组件被销毁时调用。



**异步请求在哪一步发起？**

可以在 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中， data 已经创建，可以将服务端返回的数据进行赋值。

如果异步请求不依赖 Dom，推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有一下优点：

1. 能更快获取到服务端数据，减少页面 loading 时间；
2. ssr 不支持 beforeMount、mounted 钩子函数，所以放在 created 中有助于一致性。



**5、v-if 和 v-show 的区别**

v-if：在编译过程中被转换成三元表达式，条件不满足时不渲染此节点。（动态的向 Dom 树添加或删除 Dom 元素）有更高的切换消耗。

v-show：会被编译成指令，条件不满足时控制样式将对应节点隐藏（display:none;）。有更高的初始渲染消耗。

**使用场景：**

v-if：适用于在运行时很少改变条件，不需要频繁切换条件的场景；如管理系统的权限列表的展示。

v-show：适用于需要非常频繁切换条件的场景；如前台页面的数据展示。

**扩展：display: none; 、visibility: hidden; 和 opacity:0; 之间的区别：**

1. 是否占据空间

   display: none 隐藏后不占位置，其余两个隐藏后任然占据位置。

2. 子元素是否继承

   display: none 不会被子元素继承，父元素都不存在了，子元素也不会显示出；

   visibility: hidden 会被子元素继承，通过设置子元素 visibility: visible 来显示子元素；

   opacity: 0 会被子元素继承，但不能设置子元素 opactiy: 1 来重新显示。

3. 事件绑定

   display: none 的元素都已经不在页面存在了，因此无法触发它绑定的事件；

   visibility: hidden 不会触发它上面绑定的事件；

   opacity: 0 会触发上面绑定的事件

4. 过渡动画

   transition 对 display 和 visibility 是无效的，对 opacity 是有效的。



**6、说说 vue 内置指令（有15种）**

1. v-once：定义它的元素或组件只渲染一次，包括元素或组件的所有子节点，首次渲染后，不再随数据的变化重新渲染，将被视为静态内容；

2. v-cloak：保持在元素上直到关联组件实例结束编译，是解决初始化慢导致页面闪动的最佳实践。

   当网络比较慢，网页还在加载 Vue.js，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码。可以使用该指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除来解决这一问题。

   在简单项目中，使用该指令解决屏幕闪动时好方法。但在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时就不需要该指令了。

3. v-on：用于监听 Dom 事件，如：v-on:click、v-on:keyup

4. v-bind：绑定属性，动态更新 HTML 元素上的属性，如 v-bind:class

5. v-model：在普通标签和组件上是 value 和 input 的语法糖；在普通标签：会处理拼音输入法的问题

6. v-for：循环指令

   - 编译出来的结果是 _l （是源码编译成 render 函数的一个方法，代表编译成列表，循环创建）
   - 优先级比 v-if 高，最好不要一起使用，尽量使用计算属性去解决
   - 注意增加唯一 key 值，不要使用 index 作为 key

7. v-if：可以配合 template 来使用，在 render 函数里面就是三元表达式，以下两点同。

8. v-else：

9. v-else-if：

10. v-pre：跳过这个元素与子元素的编译过程，以此来加快整个项目的编译速度。

11. v-text：更新元素的 textContent

12. v-show：使用指令来实现，最终会通过 display 来进行隐藏

13. v-html：赋值就是变量 innerHTML，注意防止 xss 攻击

14. v-is：

15. v-slot：



**7、怎样理解 Vue 的单向数据流**

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止子组件意外改变父组件的状态，从到导致应用的数据流向难以理解。

注意：在子组件直接用 v-model 绑定父组件传过来的 prop，这是不规范的写法，开发环境会报警告。



**8、computed 和 watch 的区别和运用的场景**

computed 是计算属性，依赖其他属性计算值，并且 computed 的值是有缓存的，只有当计算值发生变化时才会返回内容，它还可以设置 setter 和 getter。

watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。

计算属性一般用在模版渲染中，某个值是依赖了其他的响应式对象甚至是计算属性计算而来；

而监听属性适用于观测某个值的变化，去完成一段复杂的业务逻辑。



**9、v-if 与 v-for 为什么不建议一起使用**

v-if 与 v-for 不要在同一个标签中使用，是因为解析时先解析 v-for 再解析 v-if。如果遇到需要同时使用时，可以考虑写成计算属性的方式。


**数组增加元素的三种方法**

- unshift：添加元素要数组的头部

- push：添加元素到数组的尾部

- splice：添加元素到数组的任何位置（第一个入参是起始的索引值，第二个入参是从索引开始要删除的元素个数，第三个及以上的入参则是要新增的元素）

  ```javascript
  const arr = [1, 2]
  arr.splice(1, 0 ,3)
  ```

****

**数组删除元素的三种方法**

- shift：删除数组头部的元素
- pop：删除数组尾部的元素
- splice：删除数组任意位置的元素



**栈和队列的实现一般都依赖于数组。**

它们的区别在于，各自对数组的**增删操作**有着不一样的限制。



**栈（Stack）——只用 pop 和 push 完成增删的“数组**

栈是一种后进先出（LIFO，Last In First Out）的数据结构。

“后进先出”的过程有两个特征：

- 只允许从尾部添加元素
- 只允许从尾部取出元素



**队列（Queue）——只用 push 和 shift 完成增删的”数组“**

队列是一种先进先出（FIFO，First In First Out）的数据结构。

“先进先出”的过程有两个特征：

- 只允许从尾部添加元素
- 只允许从头部移除元素



**链表**

链表中，数据单位的名称叫做“结点”



数组在内存中最为关键的一个特征，就是它一般是对应一段位于自己上界和下界之间的、一段**连续**的内存空间。

链表中的结点，在内存中是离散的。



在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。JS 中的链表，是以嵌套的对象的形式来实现的。

```javascript
{
  // 数据域
  val: 1,
  // 指针域，指向下一个结点
  next: {
    val: 2,
      next: ...
  }
}
```

数据域存储的是当前结点所存储的数据值，指针域代表下一个结点（后继结点）的引用。



要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，有时还会设定一个 head 指针来专门指向链表的开始位置。



**链表结点的创建**

创建链表结点，我们需要一个构造函数：

```javascript
function ListNode(val) {
  this.val = val
  this.next = null
}
```

在使用构造函数创建结点时，传入 val（数据域对应的值内容）、指定 next（下一个链表结点）即可：

```javascript
const node = new ListNode(1)
node.next = new ListNode(2)
```

以上，就创建出了一个数据域值为1，next 结点数据域值为2的链表结点。



**链表元素的添加**

**任意两结点间插入一个新结点**的增加操作，需要变更的是**前驱结点和目标结点**的 next 指针指向。

```javascript
// 如果目标结点本来不存在，那么记得手动创建
const node3 = new ListNode(3)
// 把 node3 的 next 指针指向 node2（即 node1.next)
node3.next = node1.next
// 把 node1 的 next 指针指向 node3
node1.next = node3
```



**链表元素的删除**

删除的标准是：在链表的遍历过程中，无法再遍历到某个结点的存在。

比如要想遍历不到 node3，直接让她的前驱结点 node1 的 next 指针跳过它、指向 node3 的后继即可：

```javascript
node1.next = node3.next
```

如此一来， node3 就成为了一个完全不可抵达的结点了，它会被 JS 的垃圾回收器自动回收掉。

注意：在涉及链表操作的题目中，重点不是定位目标结点，而是**定位目标结点的前驱结点**。做题时，完全可以只使用一个指针（引用），这个指针用来定位目标结点的前驱结点。

```javascript
const target = node1.next
node1.next = target.next
```



**链表和数组的辨析**

在大多数的计算机语言中，数组都对应着一段连续的内存。

但 JS 中不一定是。

JS 比较特别。**如果在一个数组中只定义了一种类型的元素，比如它是一个纯数字数组，那么对应的确实是连续内存。**

**但如果定义了不同类型的元素：**

```javascript
const arr = ['haha', 1, {a:1}]
```

**它对应的就是一段非连续的内存。**此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。**“JS 数组未必是真正的数组**”



**链表的插入/删除效率较高，而访问效率较低；**

**数组的访问效率较高，而插入效率较低。**

